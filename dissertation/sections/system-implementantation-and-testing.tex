\chapter{System Implementation and Testing}

This chapter describes the implementation and evaluation of the self-documenting DSL designed for transforming SQL tables into RDF.

\section{Hardware and Sofware Requirements}

\subsection{Hardware Requirements}

The development of this DSL was conducted on a server provided by the University of Tennessee Health Science Center.  This server had the following specifications:

\begin{center}
\begin{tabular}{ll}
CPU & Dual 32-core AMD EPYC 7551 processors\\
Kernel & Linux Kernel version 4.9.0-14-amd64 x86\_64\\
Memory & 251.5939 GiB of RAM\\
Storage & 24.22 TiB\\
Operating System & Debian GNU/Linux 9.13 (stretch)\\
\end{tabular}
\end{center}

\subsection{Software Requirements}

The software dependencies for this DSL was managed using GNU Guix.  The implementation was done in GNU Guile.  The database that was used was MariaDB and the RDF datastore utilized was Virtuoso.

\section{DSL Implementation}

This DSL uses Scheme's flexible hygienic macro system to offer end-users a human-friendly syntax for interacting with SQL databases and generating RDF output bundled with transparent documentation.  The implementation of this DSL involves several key components, as illustrated in Figure \ref{fig:system-diagram} that include: defining ontologies, defining transformers, processing SQL queries, mapping SQL results to RDF, and generating documentation.  The subsections below outline the implementation of these various parts.

\subsection{Defining Transformers}

A special syntax, \codeword{define-transformer} is introduced.  This special syntax transforms a view of a database.  \codeword{define-transformer} consists of three order-agnostic clauses: \codeword{tables}, \codeword{schema-triples} and \codeword{triples}, in the form show below:

\begin{Verbatim}[frame=single]
(define-transformer function-name
  (tables (table ...) raw-forms ...)
  (schema-triples
   (subject predicate object) ...)
  (triples subject
    (verb predicate object) ...))
\end{Verbatim}

The \codeword{``tables''} clause specifies the database tables to be joined to construct the view to be transformed.  \textit{``table''} can be either of the form \textit{``table-name''} or of the form: \codeword{(JOIN-OPERATOR TABLE-NAME RAW-CONDITION)}.  \textit{``table-name''} is the name of the table.  \textit{JOIN-OPERATOR} can be one of: \codeword{join}, \codeword{left-join} and \codeword{inner-join}.  \textit{``RAW-CONDITION''} is the join condition as a raw string.  This is usually something like \codeword{"USING (SpeciesId)"}.  \textit{``raw-forms''} are expressions that must evaluate to strings to be appended to the SQL query.  The example below shows an example of doing a left join between a Genbank table with a Species table using the ``SpeciesId'' as the foreign key:

\begin{Verbatim}[frame=single]
(tables (Genbank
           (left-join Species "USING (SpeciesId)")))
\end{Verbatim}

The \codeword{schema-triples} clause specifies the list of triples to be written once when the transform starts.  An example of how this would like is:

\begin{Verbatim}[frame=single]
(schema-triples
   (gnc:nucleotide a skos:Concept)
   (gnt:hasSequence rdfs:domain gnc:nucleotide))
\end{Verbatim}

On the other hand, the \codeword{triples} clause specifies the triples to be transformed once for each row in the view.  All triples have a common \textit{subject}.  The \codeword{(verb predicate object)} clauses are described below:

\textit{``verb''} can either be a \codeword{set} or \codeword{multiset}.  For the \codeword{set} \textit{verb}, a single triple \codeword{(SUBJECT PREDICATE OBJECT-VALUE)} is written where \textit{OBJECT-VALUE} is the result of evaluating \textit{OBJECT}.  For the \codeword{multiset} \textit{verb}, \textit{OBJECT} evaluates to a list, and a triple \codeword{(SUBJECT PREDICATE OBJECT-VALUE-ELEMENT)} is created for each element \textit{OBJECT-VALUE-ELEMENT} of that list.

The \textit{``subject''} and \textit{object} expressions in the triples clause reference database fields using a \codeword{(field TABLE COLUMN)} clause where \textit{TABLE} and \textit{COLUMN} refer to the table and column of the field being referenced.  Database fields can also be referenced using \codeword{(field TABLE COLUMN ALIAS)} where ALIAS is an alias for that column in the SQL query.

The example below show's how a triple is defined:

\begin{Verbatim}[frame=single]
(triples (field Genbank Id)
    (set gnt:hasSequence (field Genbank Sequence))
    (set gnt:belongsToSpecies (field Species Fullname)))
\end{Verbatim}

\subsection{Executing a Transformer}

To execute transformers, an extra special syntax, \codeword{``with-documentation''} is provided.  This special syntax takes the form:

\begin{Verbatim}[frame=single]
(with-documentation
   (name ...)
   (connection ...)
   (table-metadata? ...)
   (prefixes ...)
   (inputs ...)
   (outputs
    `(#:documentation ...
      #:rdf ...)))
\end{Verbatim}


Each part of the \codeword{``with-documentation''} is described below:

\begin{itemize}
\item \codeword{``name''}: This represents the title used in the generated documentation markdown file.
\item \codeword{``connection''}: This contains the SQL configuration variables that will be used to connect to the database.
\item \codeword{``prefixes''}: These are various ontologies that will be included at the beginning of the RDF document.
\item \codeword{``inputs''}: This is a list of defined transformers that will be executed.
\item \codeword{``outputs''}: This specifies the file path where the RDF and documentation files will be saved.
\end{itemize}

A more complete example is shown below:

\begin{Verbatim}[frame=single]
(with-documentation
   (name "Genebank Metadata")
   (connection %connection-settings)
   (table-metadata? #f)
   (prefixes
    '(("rdf:" "<http://www.w3.org/1999/02/22-rdf-syntax-ns#>")
      ("rdfs:" "<http://www.w3.org/2000/01/rdf-schema#>")))
   (inputs
    (list
     genbank))
   (outputs
    `(#:documentation "/tmp/genbank.md"
      #:rdf "/tmp/genbank.ttl")))
\end{Verbatim}

\section{System Testing and Validation}

In this section, various tests were done to assess the performance and functionality of the self-documenting DSL designed for transformed tables into RDF format.  In addition to assessing the performance of the RDF queries, queries that are impossible to do in SQL will be highlighted.

\subsection{Query Execution Performance}

The following SQL query was run several times to count the number of publications in the Genenetwork SQL store related to diabetes:

\begin{Verbatim}[frame=single]
  SELECT COUNT(*) FROM Publication WHERE Abstract LIKE "%diabetes%";
\end{Verbatim}

The corresponding SPARQL query used to transform this SQL query into RDF format is as follows:
  
\begin{Verbatim}[frame=single]
SPARQL

PREFIX dct: <http://purl.org/dc/terms/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX fabio: <http://purl.org/spar/fabio/>

SELECT COUNT(?paper) WHERE {
       ?paper rdf:type fabio:ResearchPaper ;
               dct:abstract ?abstract .
       ?abstract bif:contains "diabetes" .
};
\end{Verbatim}

The performance results is as follows:

\begin{center}
\begin{tabular}{rr}
SQL (seconds) & SPARQL (seconds)\\[0pt]
\hline
0.09 & 0.014\\[0pt]
0.08 & 0.017\\[0pt]
0.10 & 0.016\\[0pt]
0.11 & 0.014\\[0pt]
0.09 & 0.015\\[0pt]
\end{tabular}
\end{center}

The following query is more complicated and counts the number of phenotypes that are related to diabetes:


\begin{Verbatim}[frame=single]
SELECT COUNT(Phenotype.Id) FROM PublishXRef
LEFT JOIN Publication ON Publication.Id = PublishXRef.PublicationId
LEFT JOIN Phenotype ON Phenotype.Id = PublishXRef.PhenotypeId
WHERE Publication.Abstract LIKE "%diabetes%";
\end{Verbatim}

The corresponding sparql query is:

\begin{Verbatim}[frame=single]
SPARQL

PREFIX dct: <http://purl.org/dc/terms/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX fabio: <http://purl.org/spar/fabio/>

SELECT COUNT(?phenotype) WHERE {
       ?paper rdf:type fabio:ResearchPaper ;
              dct:abstract ?abstract .
       ?abstract bif:contains "diabetes" .
       ?phenotype rdf:type gnc:Phenotype ;
                  dct:isReferencedBy ?paper .
};  
\end{Verbatim}

The corresponding results are:

\begin{center}
\begin{tabular}{rr}
SQL (seconds) & SPARQL (seconds)\\[0pt]
\hline
0.19 & 0.013\\[0pt]
0.18 & 0.015\\[0pt]
0.17 & 0.014\\[0pt]
0.18 & 0.016\\[0pt]
0.17 & 0.009\\[0pt]
\end{tabular}
\end{center}

A more complicated query that counts the number of datasets under a given group that have phenotypes related to diabetes is:

\begin{Verbatim}[frame=single]
SELECT COUNT(DISTINCT InfoFiles.DatasetId)
FROM InfoFiles
LEFT JOIN PublishFreeze ON InfoFiles.InfoPageName = PublishFreeze.Name
LEFT JOIN Datasets USING (DatasetId)
LEFT JOIN InbredSet ON InfoFiles.InbredSetId = InbredSet.InbredSetId
LEFT JOIN PublishXRef ON
 PublishXRef.InbredSetId = InfoFiles.InbredSetId
LEFT JOIN Publication ON Publication.Id = PublishXRef.PublicationId
LEFT JOIN Phenotype ON Phenotype.Id = PublishXRef.PhenotypeId
WHERE Publication.Abstract LIKE "%diabetes%";
\end{Verbatim}

The corresponding SPARQL query is:

\begin{Verbatim}[frame=single]
SPARQL

PREFIX dct: <http://purl.org/dc/terms/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX fabio: <http://purl.org/spar/fabio/>
PREFIX gnc: <http://genenetwork.org/category/>
PREFIX gnt: <http://genenetwork.org/term/>

SELECT COUNT(DISTINCT ?dataset) WHERE {
       ?paper rdf:type fabio:ResearchPaper ;
              dct:abstract ?abstract .
       ?abstract bif:contains "diabetes" .
       ?phenotype rdf:type gnc:Phenotype ;
                  gnt:belongsToGroup ?group ;
                  dct:isReferencedBy ?paper .
       ?dataset rdf:type dcat:Dataset ;
                gnt:belongsToGroup ?group .
};
\end{Verbatim}

The results are:

\begin{center}
\begin{tabular}{rr}
SQL (seconds)) & SPARQL (seconds)\\[0pt]
\hline
38.33 & 0.649\\[0pt]
38.46 & 0.124\\[0pt]
41.53 & 0.430\\[0pt]
38.53 & 0.118\\[0pt]
38.50 & 0.696\\[0pt]
\end{tabular}
\end{center}

\subsection{Federated Queries in SPARQL}

SQL is limited to querying tables that reside within the local server environment and does not have the capability to access or query external servers on the internet.  However, RDF overcomes this limitation by allowing the use of federated queries that allow a person to query external services.  The following example, highlights SQL's limitation.  It queries GeneNetwork to get the Wikidata identifier that can be used to query Wikidata as an external service, to get the longest recorded life span of a bat which is 11 years.

\begin{Verbatim}[frame=single]
SPARQL

PREFIX       wdt:  <http://www.wikidata.org/prop/direct/>
PREFIX        wd:  <http://www.wikidata.org/entity/>
PREFIX        bd:  <http://www.bigdata.com/rdf#>
PREFIX  wikibase:  <http://wikiba.se/ontology#>
PREFIX      rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX gnt: <http://genenetwork.org/term/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX gn: <http://genenetwork.org/id/>

SELECT ?years {
  ?species gnt:shortName "bat";
           rdf:isDefinedBy ?id .
SERVICE <https://query.wikidata.org/sparql> {
    ?id wdt:P4214 ?years .
  }
};
\end{Verbatim}

%%% Local Variables:
%%% ispell-local-dictionary: "en_GB-ise"
%%% End:
